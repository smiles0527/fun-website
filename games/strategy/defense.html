<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Defense: Reboot</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            background-image: 
                linear-gradient(rgba(10, 16, 20, 0.95), rgba(10, 16, 20, 0.95)),
                linear-gradient(0deg, rgba(102, 252, 241, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(102, 252, 241, 0.05) 1px, transparent 1px);
            background-size: 100% 100%, 40px 40px, 40px 40px;
            font-family: 'Rajdhani', sans-serif; 
            color: #c5c6c7; 
            user-select: none; 
        }
        body::after {
            content: "";
            position: absolute; inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 9999;
        }
        canvas { display: block; cursor: crosshair; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; }
        
        /* Top Bar */
        .top-bar {
            position: absolute; top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(11, 12, 16, 0.8); border: 1px solid rgba(102, 252, 241, 0.3);
            padding: 15px 30px; pointer-events: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        .stats { display: flex; gap: 30px; font-size: 1.4rem; font-weight: bold; letter-spacing: 1px; }
        .stat { display: flex; align-items: center; gap: 8px; }
        .stat i { color: #66fcf1; }
        .stat.hp i { color: #e17055; }
        .stat.cash i { color: #f1c40f; }

        /* Build Menu */
        .build-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(11, 12, 16, 0.8);
            padding: 15px; border-radius: 0; border: 1px solid rgba(102, 252, 241, 0.3);
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .turret-btn {
            width: 60px; height: 80px;
            background: rgba(31, 40, 51, 0.4); border: 1px solid #45a29e;
            color: #fff; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: 0.2s; position: relative;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .turret-btn:hover { background: #45a29e; color: #000; transform: translateY(-5px); }
        .turret-btn.selected { border-color: #66fcf1; box-shadow: 0 0 15px #66fcf1; background: rgba(102, 252, 241, 0.1); }
        .turret-btn.disabled { opacity: 0.5; filter: grayscale(1); cursor: not-allowed; }
        .t-icon { font-size: 1.5rem; margin-bottom: 5px; }
        .t-cost { font-size: 0.9rem; color: #f1c40f; font-weight: bold; }
        .t-key { position: absolute; top: 2px; left: 4px; font-size: 0.7rem; color: #66fcf1; }

        /* Wave Button */
        .wave-btn {
            background: linear-gradient(45deg, #45a29e, #66fcf1); border: none;
            color: #000; font-weight: bold; padding: 0 30px; cursor: pointer;
            font-family: 'Rajdhani', sans-serif; font-size: 1.2rem;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: 0.2s;
        }
        .wave-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px #66fcf1; }

        /* Context Menu */
        #ctx-menu {
            position: absolute; display: none; background: rgba(11, 12, 16, 0.95);
            border: 1px solid #66fcf1; padding: 10px; pointer-events: auto; min-width: 150px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .ctx-btn {
            display: block; width: 100%; padding: 8px 12px;
            background: transparent; border: 1px solid transparent;
            color: #fff; text-align: left; cursor: pointer; font-family: inherit; font-size: 1rem;
            margin-bottom: 5px;
        }
        .ctx-btn:hover { background: rgba(102, 252, 241, 0.2); border-color: #66fcf1; }
        .ctx-btn span { float: right; color: #f1c40f; }

        /* Notifications */
        #toast {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(225, 112, 85, 0.9); color: #fff; padding: 10px 20px;
            border-radius: 4px; font-weight: bold; opacity: 0; transition: 0.3s;
        }

        /* Controls */
        .controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; gap: 10px; pointer-events: auto;
        }
        .ctrl-btn {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(11, 12, 16, 0.8); border: 1px solid #66fcf1;
            color: #66fcf1; font-size: 1.5rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: 0.2s;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .ctrl-btn:hover { background: #66fcf1; color: #000; box-shadow: 0 0 15px #66fcf1; }
        .ctrl-btn.abort { border-color: #ff4757; color: #ff4757; width: auto; padding: 0 20px; border-radius: 25px; font-family: 'Rajdhani', sans-serif; font-weight: bold; font-size: 1.2rem; }
        .ctrl-btn.abort:hover { background: #ff4757; color: #fff; box-shadow: 0 0 15px #ff4757; }
        
        /* Shop */
        #shop-modal {
            display: none; position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; height: 90%;
            background: rgba(11, 12, 16, 0.98); 
            border: 1px solid #66fcf1;
            display: flex; flex-direction: column;
            box-shadow: 0 0 50px rgba(102, 252, 241, 0.1);
            z-index: 1000;
            pointer-events: auto; /* CRITICAL FIX */
            backdrop-filter: blur(10px);
        }
        .shop-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 20px 30px; border-bottom: 1px solid rgba(102, 252, 241, 0.3);
            background: rgba(20, 20, 25, 0.95);
        }
        .shop-header h2 { margin: 0; color: #66fcf1; font-family: 'Rajdhani'; font-size: 2.5rem; letter-spacing: 4px; text-shadow: 0 0 10px rgba(102, 252, 241, 0.5); }
        .shop-tabs {
            display: flex; gap: 2px; padding: 0; background: rgba(0,0,0,0.8); overflow-x: auto;
            border-bottom: 1px solid rgba(102, 252, 241, 0.3);
        }
        .shop-tab {
            padding: 15px 30px; background: #0b0c10; color: #888; border: none; border-right: 1px solid #222;
            cursor: pointer; font-family: 'Rajdhani'; font-weight: bold; font-size: 1.2rem; transition: 0.2s;
            white-space: nowrap; flex-grow: 1; text-align: center;
        }
        .shop-tab:hover { color: #fff; background: #1f2833; }
        .shop-tab.active { color: #000; background: #66fcf1; box-shadow: 0 0 20px rgba(102, 252, 241, 0.3); }
        
        .shop-content {
            flex: 1; overflow-y: auto; padding: 30px;
            display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 25px;
            background: 
                linear-gradient(rgba(11, 12, 16, 0.9), rgba(11, 12, 16, 0.9)),
                linear-gradient(0deg, rgba(102, 252, 241, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(102, 252, 241, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 20px 20px, 20px 20px;
        }
        .shop-item {
            background: rgba(31, 40, 51, 0.6); border: 1px solid rgba(102, 252, 241, 0.2);
            padding: 20px; display: flex; flex-direction: column; gap: 15px;
            transition: 0.2s; position: relative; overflow: hidden;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
        }
        .shop-item:hover { border-color: #66fcf1; background: rgba(31, 40, 51, 0.9); transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .shop-item h3 { margin: 0; color: #fff; font-size: 1.4rem; letter-spacing: 1px; }
        .shop-item p { margin: 0; color: #aeb6bf; font-size: 0.95rem; line-height: 1.5; flex-grow: 1; }
        
        .progress-bar {
            height: 6px; background: #111; width: 100%; position: relative; margin-top: 5px;
        }
        .progress-fill {
            height: 100%; background: #66fcf1; width: 0%; transition: 0.3s;
            box-shadow: 0 0 10px #66fcf1;
        }
        
        .shop-btn {
            background: transparent; border: 1px solid #66fcf1;
            color: #66fcf1; font-weight: bold; padding: 12px; cursor: pointer;
            font-family: inherit; margin-top: 10px; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.2s; font-size: 1rem;
        }
        .shop-btn:hover:not(:disabled) { background: #66fcf1; color: #000; box-shadow: 0 0 20px rgba(102, 252, 241, 0.5); }
        .shop-btn:disabled { opacity: 0.5; border-color: #444; color: #444; cursor: not-allowed; }
        .shop-lvl { font-size: 0.8rem; color: #66fcf1; opacity: 0.7; text-align: right; }

        /* Game Over */
        #game-over {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            display: none;
        }
        #game-over h1 { font-size: 5rem; color: #e17055; margin: 0; }
        #restart-btn {
            margin-top: 20px; padding: 15px 40px; background: transparent;
            border: 2px solid #66fcf1; color: #66fcf1; font-size: 1.5rem; cursor: pointer;
            font-family: inherit; transition: 0.2s;
        }
        #restart-btn:hover { background: #66fcf1; color: #000; }
        
        /* Global Button Feedback */
        button:active, .turret-btn:active, .ctrl-btn:active, .shop-tab:active, .shop-btn:active {
            transform: scale(0.95) !important;
        }
        button, .turret-btn, .ctrl-btn, .shop-tab, .shop-btn, .ctx-btn {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="game" oncontextmenu="return false;"></canvas>
    
    <div id="ui-layer">
        <div class="top-bar">
            <div class="stats">
                <div class="stat hp"><i class="ri-heart-pulse-fill"></i> <span id="ui-hp">100</span></div>
                <div class="stat cash"><i class="ri-money-dollar-circle-fill"></i> <span id="ui-cash">150</span></div>
                <div class="stat"><i class="ri-flag-fill"></i> Wave <span id="ui-wave">1</span></div>
            </div>
            <a href="../../index.html" style="color: #fff; text-decoration: none; border: 1px solid #66fcf1; padding: 5px 15px;">Exit</a>
        </div>

        <div class="build-bar">
            <div class="turret-btn" onclick="selectBuild(0)" id="btn-0">
                <div class="t-key">1</div>
                <div class="t-icon"><i class="ri-focus-3-line"></i></div>
                <div class="t-cost">30</div>
            </div>
            <div class="turret-btn" onclick="selectBuild(1)" id="btn-1">
                <div class="t-key">2</div>
                <div class="t-icon"><i class="ri-crosshair-2-line"></i></div>
                <div class="t-cost">120</div>
            </div>
            <div class="turret-btn" onclick="selectBuild(2)" id="btn-2">
                <div class="t-key">3</div>
                <div class="t-icon"><i class="ri-fire-line"></i></div>
                <div class="t-cost">200</div>
            </div>
            <div class="turret-btn" onclick="selectBuild(3)" id="btn-3">
                <div class="t-key">4</div>
                <div class="t-icon"><i class="ri-snowy-line"></i></div>
                <div class="t-cost">150</div>
            </div>
            <div class="turret-btn" onclick="selectBuild(4)" id="btn-4" style="border-color: #bdc3c7;">
                <div class="t-key">5</div>
                <div class="t-icon"><i class="ri-stop-circle-line"></i></div>
                <div class="t-cost">5</div>
            </div>
            <div class="turret-btn" onclick="selectBuild(-1)" id="btn-cancel" style="border-color: #ff4757;">
                <div class="t-key">ESC</div>
                <div class="t-icon"><i class="ri-close-circle-line"></i></div>
                <div class="t-cost">CANCEL</div>
            </div>
            <button class="wave-btn" onclick="nextWave()" id="btn-wave">START</button>
        </div>

        <div id="ctx-menu">
            <button class="ctx-btn" onclick="upgradeTurret()">Upgrade <span id="ctx-up-cost"></span></button>
            <button class="ctx-btn" onclick="sellTurret()" style="color:#e17055; border-color:#e17055;">Sell <span id="ctx-sell-val"></span></button>
            <button class="ctx-btn" onclick="closeCtxMenu()" style="color:#ccc; border-top:1px solid #333;">Close</button>
        </div>

        <div id="toast">Notification</div>

        <div id="shop-modal" style="display: none;">
            <div class="shop-header">
                <div style="display:flex; flex-direction:column;">
                    <h2>RESEARCH LAB</h2>
                    <small style="color:#888; font-size:0.8rem;">Click tabs to switch categories</small>
                </div>
                <div style="display:flex; align-items:center; gap:20px;">
                    <div style="font-size:1.5rem; color:#f1c40f; font-weight:bold;"><i class="ri-money-dollar-circle-fill"></i> <span id="shop-cash">0</span></div>
                    <button class="ctrl-btn" onclick="toggleShop()"><i class="ri-close-line"></i></button>
                </div>
            </div>
            <div class="shop-tabs" id="shop-tabs">
                <!-- Tabs injected JS -->
            </div>
            <div class="shop-content" id="shop-content">
                <!-- Items injected JS -->
            </div>
        </div>

        <div class="controls">
            <button class="ctrl-btn" onclick="toggleShop()" title="Research Lab" style="border-color:#f1c40f; color:#f1c40f;"><i class="ri-flask-line"></i></button>
            <button class="ctrl-btn" onclick="sellAllTurrets()" title="Sell All Turrets"><i class="ri-currency-line"></i></button>
            <button class="ctrl-btn" onclick="centerCamera()" title="Recenter Camera"><i class="ri-focus-mode-line"></i></button>
            <button class="ctrl-btn" onclick="systemPurge()" title="System Purge ($300)" style="border-color:#e17055; color:#e17055;"><i class="ri-alarm-warning-line"></i></button>
            <button class="ctrl-btn" onclick="resetGame()" title="Reset Game"><i class="ri-restart-line"></i></button>
            <button class="ctrl-btn" onclick="togglePause()" id="btn-pause" title="Pause/Resume"><i class="ri-pause-line"></i></button>
            <button class="ctrl-btn abort" onclick="abortGame()" title="Abort Wave"><i class="ri-stop-circle-line"></i> ABORT</button>
        </div>

        <div id="game-over">
            <h1>SYSTEM FAILURE</h1>
            <button id="restart-btn" onclick="location.reload()">REBOOT</button>
        </div>
    </div>

    <script>
        // --- Engine & Config ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        const TILE_SIZE = 40;
        const GRID_W = 100; // Huge map (4000x4000px)
        const GRID_H = 100;
        
        let camera = { x: 0, y: 0, zoom: 1 };
        let isPanning = false;
        let lastMouse = { x: 0, y: 0 };
        
        // Turret Types
        const TYPES = [
            { name: 'Gunner', cost: 30,  range: 3.5, rate: 25, dmg: 10, color: '#45a29e', type: 'proj' },
            { name: 'Sniper', cost: 120, range: 8,   rate: 80, dmg: 80, color: '#66fcf1', type: 'proj', speed: 15 },
            { name: 'Pyro',   cost: 200, range: 2.5, rate: 5,  dmg: 2,  color: '#e17055', type: 'aura' },
            { name: 'Frost',  cost: 150, range: 4,   rate: 40, dmg: 5,  color: '#74b9ff', type: 'proj', slow: 0.5 },
            { name: 'Wall',   cost: 5,   range: 0,   rate: 0,  dmg: 0,  color: '#bdc3c7', type: 'wall' }
        ];

        const RESEARCH = [];
        const CATEGORIES = [
            'Weaponry', 'Defense', 'Economy', 'Tech', 'Omega'
        ];
        
        // Weaponry
        ['Damage', 'Range', 'Fire Rate', 'Bullet Speed', 'Crit Chance'].forEach((stat, i) => {
            for(let j=1; j<=2; j++) {
                RESEARCH.push({ 
                    id: `wep_${i}_${j}`, cat: 'Weaponry', name: `${stat} Mk.${j}`, max: 10, cost: 500 * j, 
                    desc: `Increases turret ${stat.toLowerCase()} by ${5 * j}%.`, 
                    type: 'stat', stat: stat, val: 0.05 * j 
                });
            }
        });

        // Defense (Merged Architecture & Core Systems)
        RESEARCH.push({ id: 'shielding', cat: 'Defense', name: 'Core Shielding', max: 10, cost: 300, desc: '-5% Core Damage Taken.', type: 'stat' });
        RESEARCH.push({ id: 'core_hp', cat: 'Defense', name: 'Core Integrity', max: 10, cost: 400, desc: '+20 Core HP.', type: 'stat' });
        RESEARCH.push({ id: 'core_regen', cat: 'Defense', name: 'Auto-Repair', max: 5, cost: 1200, desc: 'Regen 1 HP/wave.', type: 'stat' });
        RESEARCH.push({ id: 'thorns', cat: 'Defense', name: 'Firewall', max: 5, cost: 1000, desc: 'Attackers take 10 dmg.', type: 'stat' });

        // Economy
        RESEARCH.push({ id: 'interest', cat: 'Economy', name: 'Compound Interest', max: 5, cost: 2000, desc: '+1% Interest Rate.', type: 'stat' });
        RESEARCH.push({ id: 'bounty', cat: 'Economy', name: 'Data Mining', max: 10, cost: 500, desc: '+5% Cash from enemies.', type: 'stat' });
        RESEARCH.push({ id: 'start_cash', cat: 'Economy', name: 'Seed Funding', max: 5, cost: 400, desc: '+50 Starting Cash.', type: 'stat' });
        RESEARCH.push({ id: 'build_cost', cat: 'Economy', name: 'Nanofabrication', max: 5, cost: 1000, desc: '-5% Building Cost.', type: 'stat' });
        RESEARCH.push({ id: 'refund', cat: 'Economy', name: 'Recycle Protocol', max: 5, cost: 800, desc: '+10% Sell Refund.', type: 'stat' });

        // Tech (Merged Chronomancy, Matter, Cyber, Entropy, Visuals)
        RESEARCH.push({ id: 'flux', cat: 'Tech', name: 'Temporal Flux', max: 5, cost: 1500, desc: 'Enemies have a 1-5% chance to glitch back.', type: 'mech' });
        RESEARCH.push({ id: 'slow_aura', cat: 'Tech', name: 'Time Dilation', max: 5, cost: 2000, desc: 'Global 5% enemy slow.', type: 'stat' });
        RESEARCH.push({ id: 'pierce', cat: 'Tech', name: 'Phase Rounds', max: 3, cost: 3000, desc: '+1 Pierce for Snipers.', type: 'stat' });
        RESEARCH.push({ id: 'splash', cat: 'Tech', name: 'Unstable Mass', max: 3, cost: 2500, desc: 'Gunners deal small splash dmg.', type: 'mech' });
        RESEARCH.push({ id: 'hack', cat: 'Tech', name: 'Bounty Hack', max: 5, cost: 1000, desc: 'Chance for double cash.', type: 'mech' });
        RESEARCH.push({ id: 'stun', cat: 'Tech', name: 'Short Circuit', max: 5, cost: 1500, desc: 'Chance to stun enemies on hit.', type: 'mech' });
        RESEARCH.push({ id: 'chaos_dmg', cat: 'Tech', name: 'Wild Magic', max: 5, cost: 1200, desc: 'Turret damage fluctuates +/- 50%.', type: 'mech' });
        RESEARCH.push({ id: 'crit_dmg', cat: 'Tech', name: 'Fatal Error', max: 5, cost: 1500, desc: '+50% Crit Damage.', type: 'stat' });
        // Visuals merged into Tech as cheap upgrades
        RESEARCH.push({ id: 'chromatic', cat: 'Tech', name: 'RGB Split', max: 5, cost: 200, desc: 'Adds chromatic aberration effect.', type: 'visual' });
        RESEARCH.push({ id: 'shake', cat: 'Tech', name: 'Screen Shake', max: 5, cost: 200, desc: 'Adds impact shake.', type: 'visual' });
        RESEARCH.push({ id: 'bloom', cat: 'Tech', name: 'Neon Overdrive', max: 5, cost: 200, desc: 'Increases glow intensity.', type: 'visual' });

        // Omega
        RESEARCH.push({ id: 'resonance', cat: 'Omega', name: 'Core Resonance', max: 5, cost: 5000, desc: 'Core pulses massive damage.', type: 'mech' });
        RESEARCH.push({ id: 'swarm', cat: 'Omega', name: 'Nano-Swarm', max: 5, cost: 4000, desc: 'Enemies leave damaging clouds.', type: 'mech' });
        RESEARCH.push({ id: 'overclock', cat: 'Omega', name: 'Sys-Overclock', max: 5, cost: 6000, desc: '+25% Global Fire Rate.', type: 'stat' });

        // Fill remaining
        let counter = 0;
        while(RESEARCH.length < 60) {
            RESEARCH.push({ 
                id: `gen_${counter}`, cat: 'Weaponry', name: `Output Tuner V${counter}`, max: 5, cost: 200 + counter*50, 
                desc: `+1% Global Damage.`, type: 'stat' 
            });
            counter++;
        }

        // Game State
        let game = {
            hp: 100,
            cash: 150, // Will be overridden by load or reset
            wave: 1,
            active: false,
            over: false,
            paused: false,
            frame: 0,
            grid: [], // 0: Empty, 1: Wall/Turret, 2: Core, 3: Spawn
            flow: [], // Distance map
            turrets: [],
            enemies: [],
            bullets: [],
            particles: [],
            clouds: [],
            upgrades: {}, // Dynamic
            spawns: [],
            core: {x:0, y:0},
            selection: -1, // -1: None, 0-4: Build Type
            hover: {x:-1, y:-1},
            focus: null, // Clicked turret
            shopCat: 'Weaponry'
        };

        // Visuals
        const IMAGES = {}; // Placeholder if we used images, but we use canvas shapes
        let pulse = 0;

        // --- Initialization ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Center camera initially
            if (game.frame === 0) {
                camera.zoom = 1;
                camera.x = game.core.x * TILE_SIZE + TILE_SIZE/2;
                camera.y = game.core.y * TILE_SIZE + TILE_SIZE/2;
            }
        }

        function resetGrid() {
            game.grid = new Int8Array(GRID_W * GRID_H).fill(0);
            game.flow = new Int32Array(GRID_W * GRID_H).fill(9999);
            
            // Center Core
            game.core.x = Math.floor(GRID_W / 2);
            game.core.y = Math.floor(GRID_H / 2);
            setGrid(game.core.x, game.core.y, 2);

            // Spawns - Many more points
            game.spawns = [];
            // Top & Bottom edges
            for(let x=10; x<GRID_W-10; x+=20) {
                game.spawns.push({x: x, y: 0});
                game.spawns.push({x: x, y: GRID_H-1});
            }
            // Left & Right edges
            for(let y=10; y<GRID_H-10; y+=20) {
                game.spawns.push({x: 0, y: y});
                game.spawns.push({x: GRID_W-1, y: y});
            }
            
            game.spawns.forEach(s => setGrid(s.x, s.y, 3));
            
            game.turrets = [];
            game.enemies = [];
            game.bullets = [];
            updateFlow();
        }

        // Helpers for flat array
        function getGrid(x, y) { 
            if(x<0 || x>=GRID_W || y<0 || y>=GRID_H) return 1; // Out of bounds is wall
            return game.grid[y * GRID_W + x]; 
        }
        function setGrid(x, y, v) { 
            if(x>=0 && x<GRID_W && y>=0 && y<GRID_H) game.grid[y * GRID_W + x] = v; 
        }
        function getFlow(x, y) {
            if(x<0 || x>=GRID_W || y<0 || y>=GRID_H) return 9999;
            return game.flow[y * GRID_W + x];
        }

        // --- Pathfinding (BFS) ---
        function updateFlow() {
            game.flow.fill(9999);
            let q = [game.core];
            let head = 0;
            
            // Set core distance to 0
            game.flow[game.core.y * GRID_W + game.core.x] = 0;

            const DIRS = [[0,1], [0,-1], [1,0], [-1,0]];

            while(head < q.length) {
                let curr = q[head++];
                let dist = game.flow[curr.y * GRID_W + curr.x];

                for(let i=0; i<4; i++) {
                    let nx = curr.x + DIRS[i][0];
                    let ny = curr.y + DIRS[i][1];

                    if(nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                        let idx = ny * GRID_W + nx;
                        if(game.grid[idx] !== 1 && game.flow[idx] === 9999) { // Not Wall & Unvisited
                            game.flow[idx] = dist + 1;
                            q.push({x: nx, y: ny});
                        }
                    }
                }
            }
        }

        // --- Game Logic ---
        function getStat(t, stat) {
            let base = 0;
            if(stat === 'dmg') base = t.type.dmg;
            if(stat === 'range') base = t.type.range; // Tiles
            if(stat === 'rate') base = t.type.rate; // Frames
            if(stat === 'speed') base = t.type.speed || 10;

            let mult = 1;
            let add = 0;

            // Level Scaling
            if(t.level && t.level > 1) {
                if(stat === 'dmg') mult += (t.level - 1) * 0.25;
                if(stat === 'range') mult += (t.level - 1) * 0.05;
            }

            if(stat === 'dmg') {
                // Procedural & Manual Dmg Upgrades
                for(let k in game.upgrades) {
                    if(k.startsWith('wep_0_')) mult += game.upgrades[k] * 0.05;
                    if(k.startsWith('gen_')) mult += game.upgrades[k] * 0.01;
                }
                if(game.upgrades.chaos_dmg) mult *= (0.5 + Math.random());
                if(game.upgrades.crit_dmg && Math.random() < 0.2) mult *= 1.5;
            }
            if(stat === 'range') {
                for(let k in game.upgrades) if(k.startsWith('wep_1_')) mult += game.upgrades[k] * 0.05;
            }
            if(stat === 'rate') {
                let speedMult = 1 + (game.upgrades.overclock || 0) * 0.05;
                if(t.level && t.level > 1) speedMult += (t.level - 1) * 0.1;
                for(let k in game.upgrades) if(k.startsWith('wep_2_')) speedMult += game.upgrades[k] * 0.05;
                return Math.max(1, base / speedMult);
            }

            return (base + add) * mult;
        }

        function update() {
            if(game.over || game.paused) return;
            game.frame++;

            // --- Upgrades: Core Resonance ---
            if(game.active && game.upgrades.resonance > 0) {
                if(game.frame % 180 === 0) { // Every 3s
                    let dmg = 50 * game.upgrades.resonance;
                    game.bullets.push({
                        x: game.core.x * TILE_SIZE + TILE_SIZE/2, 
                        y: game.core.y * TILE_SIZE + TILE_SIZE/2,
                        vx: 0, vy: 0, life: 30, color: '#f1c40f', type: 'pulse', r: 0
                    });
                    for(let e of game.enemies) {
                        e.hp -= dmg;
                        if(e.hp <= 0) killEnemy(e);
                    }
                }
            }

            // --- Clouds (Nano-Swarm) ---
            for(let i = game.clouds.length - 1; i >= 0; i--) {
                let c = game.clouds[i];
                c.life--;
                if(game.frame % 10 === 0) { 
                    for(let e of game.enemies) {
                        let dx = e.x - c.x;
                        let dy = e.y - c.y;
                        if(dx*dx + dy*dy < 2500) { 
                            e.hp -= c.dmg;
                            if(e.hp <= 0) killEnemy(e);
                        }
                    }
                }
                if(c.life <= 0) game.clouds.splice(i, 1);
            }

            // --- Spawning ---
            if(game.active) {
                if(game.enemiesToSpawn > 0 && game.frame % 30 === 0) { 
                    spawnEnemy();
                    game.enemiesToSpawn--;
                } else if(game.enemiesToSpawn <= 0 && game.enemies.length === 0) {
                    endWave();
                }
            }

            // --- Entities ---
            // Turrets
            for(let t of game.turrets) {
                if(t.type.type === 'wall') continue;
                if(t.cooldown > 0) t.cooldown--;

                let rangeTiles = getStat(t, 'range');
                let rangePx = rangeTiles * TILE_SIZE;
                let rate = getStat(t, 'rate');
                let dmg = getStat(t, 'dmg');

                let target = null;
                let minD = rangePx * rangePx;

                for(let e of game.enemies) {
                    let dx = e.x - t.x;
                    let dy = e.y - t.y;
                    let d = dx*dx + dy*dy;
                    if(d < minD) {
                        minD = d;
                        target = e;
                        if(t.type.type === 'aura') {
                            if(t.cooldown <= 0) {
                                e.hp -= dmg;
                                if(e.hp <= 0) killEnemy(e);
                            }
                        }
                    }
                }

                if(t.type.type === 'aura' && target && t.cooldown <= 0) {
                    t.cooldown = rate; 
                } else if (target) {
                    t.angle = Math.atan2(target.y - t.y, target.x - t.x);
                    
                    if (t.cooldown <= 0) {
                        let speed = getStat(t, 'speed');
                        game.bullets.push({
                            x: t.x, y: t.y,
                            vx: Math.cos(t.angle) * speed,
                            vy: Math.sin(t.angle) * speed,
                            dmg: dmg,
                            color: t.type.color,
                            slow: t.type.slow,
                            life: 60,
                            pierce: (game.upgrades.pierce || 0)
                        });
                        t.cooldown = rate;
                    }
                }
            }

            // Bullets
            for(let i = game.bullets.length - 1; i >= 0; i--) {
                let b = game.bullets[i];
                if(b.type === 'pulse') continue;

                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                
                let hit = false;
                for(let e of game.enemies) {
                    if(b.hitList && b.hitList.includes(e)) continue;

                    let dx = b.x - e.x;
                    let dy = b.y - e.y;
                    if(dx*dx + dy*dy < 225) { 
                        e.hp -= b.dmg;
                        if(b.slow) e.slow = 60; 
                        if(game.upgrades.stun && Math.random() < 0.1 * game.upgrades.stun) e.stun = 30;

                        createParticle(b.x, b.y, 'spark', b.color); // Hit effect

                        // Splash Damage
                        if(game.upgrades.splash > 0) {
                            let splashRange = 60; // Px
                            let splashDmg = b.dmg * 0.2 * game.upgrades.splash;
                            createParticle(b.x, b.y, 'shockwave', b.color);
                            for(let sE of game.enemies) {
                                if(sE === e) continue;
                                let sDx = sE.x - b.x;
                                let sDy = sE.y - b.y;
                                if(sDx*sDx + sDy*sDy < splashRange*splashRange) {
                                    sE.hp -= splashDmg;
                                    if(sE.hp <= 0) killEnemy(sE);
                                }
                            }
                        }

                        if(e.hp <= 0) killEnemy(e);
                        
                        hit = true;
                        
                        if(b.pierce > 0) {
                            b.pierce--;
                            if(!b.hitList) b.hitList = [];
                            b.hitList.push(e);
                            hit = false;
                        }
                        break;
                    }
                }
                if(hit || b.life <= 0) game.bullets.splice(i, 1);
            }
            // Cleanup pulse
            for(let i=game.bullets.length-1; i>=0; i--) {
                if(game.bullets[i].type === 'pulse' && game.bullets[i].life <= 0) game.bullets.splice(i, 1);
                else if(game.bullets[i].type === 'pulse') game.bullets[i].life--;
            }

            // Enemies
            for(let i = game.enemies.length - 1; i >= 0; i--) {
                let e = game.enemies[i];
                
                if(e.stun > 0) { e.stun--; continue; }

                let gx = Math.floor(e.x / TILE_SIZE);
                let gy = Math.floor(e.y / TILE_SIZE);
                
                if(gx === game.core.x && gy === game.core.y) {
                    let dmg = 5;
                    if(game.upgrades.shielding > 0) {
                        dmg *= (1 - game.upgrades.shielding * 0.05);
                    }
                    
                    game.hp -= dmg;
                    updateUI();
                    game.enemies.splice(i, 1);
                    if(game.hp <= 0) gameOver();
                    continue;
                }

                let best = {x: gx, y: gy, d: getFlow(gx, gy)};
                const DIRS = [[0,1], [0,-1], [1,0], [-1,0]];
                for(let dir of DIRS) {
                    let nx = gx + dir[0];
                    let ny = gy + dir[1];
                    let d = getFlow(nx, ny);
                    if(d < best.d) best = {x: nx, y: ny, d: d};
                }

                let tx = best.x * TILE_SIZE + TILE_SIZE/2;
                let ty = best.y * TILE_SIZE + TILE_SIZE/2;
                let dx = tx - e.x;
                let dy = ty - e.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                let speed = e.slow > 0 ? e.maxSpeed * 0.5 : e.maxSpeed;
                if(e.slow > 0) e.slow--;
                
                if(game.upgrades.slow_aura) speed *= (1 - game.upgrades.slow_aura * 0.05);
                if(game.upgrades.flux && Math.random() < 0.01 * game.upgrades.flux) {
                    e.x -= dx * 5; e.y -= dy * 5; 
                }

                if(dist > 1) {
                    e.x += (dx/dist) * speed;
                    e.y += (dy/dist) * speed;
                } else {
                    e.x = tx; e.y = ty;
                }

                // Glitch Mechanic
                if(e.type === 'glitch') {
                    e.glitchTimer = (e.glitchTimer || 0) + 1;
                    if(e.glitchTimer > 120 && Math.random() < 0.05) { // Every ~2s, chance to teleport
                        e.glitchTimer = 0;
                        let jump = 40 + Math.random() * 40;
                        e.x += (dx/dist) * jump; // Teleport forward
                        e.y += (dy/dist) * jump;
                        createParticle(e.x, e.y, 'spark', '#66fcf1');
                    }
                }
            }

            // Particles
            for(let i = game.particles.length - 1; i >= 0; i--) {
                let p = game.particles[i];
                p.life--;
                p.x += p.vx;
                p.y += p.vy;
                if(p.type === 'debris') p.vy += 0.2; // Gravity
                if(p.life <= 0) game.particles.splice(i, 1);
            }
        }

        function killEnemy(e) {
            if(game.upgrades.swarm > 0) {
                game.clouds.push({
                    x: e.x, y: e.y, life: 180, dmg: 10 * game.upgrades.swarm
                });
            }

            for(let i=0; i<5; i++) createParticle(e.x, e.y, 'debris', e.type === 'glitch' ? '#fff' : '#e74c3c');
            createParticle(e.x, e.y, 'text', '+' + (e.bounty + (game.upgrades.bounty ? Math.floor(e.bounty * game.upgrades.bounty * 0.05) : 0)));

            let bonus = 0;
            if(game.upgrades.hack > 0) {
                if(Math.random() < 0.1 * game.upgrades.hack) bonus = e.bounty;
            }
            if(game.upgrades.bounty) bonus += Math.floor(e.bounty * game.upgrades.bounty * 0.05);

            let idx = game.enemies.indexOf(e);
            if(idx > -1) {
                game.enemies.splice(idx, 1);
                game.cash += e.bounty + bonus;
                updateUI();
            }
        }

        function spawnEnemy() {
            let spawn = game.spawns[Math.floor(Math.random() * game.spawns.length)];
            let isGlitch = game.wave > 3 && Math.random() < 0.15; // 15% chance for Glitch enemy after wave 3
            
            game.enemies.push({
                x: spawn.x * TILE_SIZE + TILE_SIZE/2,
                y: spawn.y * TILE_SIZE + TILE_SIZE/2,
                hp: (isGlitch ? 10 : 20) * Math.pow(1.10, game.wave), // Reduced scaling from 1.15 to 1.10
                maxSpeed: (isGlitch ? 4 : 2) + Math.min(4, game.wave * 0.1),
                slow: 0,
                stun: 0,
                bounty: (isGlitch ? 15 : 5) + Math.floor(game.wave),
                type: isGlitch ? 'glitch' : 'normal',
                glitchTimer: 0
            });
        }

        function createParticle(x, y, type, color) {
            let p = { x: x, y: y, type: type, life: 60, color: color, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5 };
            if(type === 'spark') { p.life = 20; p.size = 2 + Math.random()*2; }
            if(type === 'debris') { p.life = 40; p.size = 3 + Math.random()*3; p.vx *= 2; p.vy *= 2; }
            if(type === 'shockwave') { p.life = 30; p.size = 10; p.vx = 0; p.vy = 0; }
            if(type === 'text') { p.life = 40; p.vy = -1; p.text = color; p.color = '#fff'; } // color arg used as text
            game.particles.push(p);
        }

        function systemPurge() {
            try {
                if(game.cash >= 300) {
                    game.cash -= 300;
                    updateUI();
                    
                    // Push back all enemies
                    for(let e of game.enemies) {
                        let dx = e.x - (game.core.x * TILE_SIZE);
                        let dy = e.y - (game.core.y * TILE_SIZE);
                        let dist = Math.sqrt(dx*dx + dy*dy);
                        if(dist > 0) {
                            e.x += (dx/dist) * 200; // Push back 200px
                            e.y += (dy/dist) * 200;
                            e.stun = 60; // Stun for 1s
                            e.hp -= 20; // Damage
                            if(e.hp <= 0) killEnemy(e);
                        }
                    }
                    
                    // Visuals
                    game.bullets.push({
                        x: game.core.x * TILE_SIZE + TILE_SIZE/2, 
                        y: game.core.y * TILE_SIZE + TILE_SIZE/2,
                        vx: 0, vy: 0, life: 60, color: '#e17055', type: 'pulse', r: 0
                    });
                    
                    showToast("SYSTEM PURGE INITIATED");
                } else {
                    showToast("Need $300 for Purge");
                }
            } catch(e) {
                console.error(e);
                showToast("Error: " + e.message);
            }
        }

        function nextWave() {
            if(game.active) return;
            game.active = true;
            game.enemiesToSpawn = 10 + Math.floor(Math.pow(game.wave, 1.1) * 5); // Reduced scaling from 1.2 to 1.1
            document.getElementById('btn-wave').style.display = 'none';
        }

        function endWave() {
            game.active = false;
            game.wave++;
            
            // Economy: Interest
            let interestRate = 0.1 + (game.upgrades.interest || 0) * 0.01;
            game.cash += Math.floor(game.cash * interestRate);
            
            // Core Regen
            if(game.upgrades.core_regen) {
                game.hp = Math.min(100 + (game.upgrades.core_hp || 0)*20, game.hp + game.upgrades.core_regen);
            }

            updateUI();
            document.getElementById('btn-wave').style.display = 'block';
            saveGame();
        }

        function gameOver() {
            game.over = true;
            localStorage.removeItem('coreDefenseSave'); // Clear save on death
            document.getElementById('game-over').style.display = 'flex';
        }

        function togglePause() {
            game.paused = !game.paused;
            let btn = document.getElementById('btn-pause');
            btn.innerHTML = game.paused ? '<i class="ri-play-fill"></i>' : '<i class="ri-pause-line"></i>';
        }

        function toggleShop() {
            let shop = document.getElementById('shop-modal');
            if(shop.style.display === 'flex') {
                shop.style.display = 'none';
                game.paused = false;
            } else {
                shop.style.display = 'flex';
                game.paused = true;
                renderShop();
            }
            updateUI();
        }

        function renderShop() {
            document.getElementById('shop-cash').innerText = game.cash;

            // Render Tabs
            let tabs = document.getElementById('shop-tabs');
            tabs.innerHTML = '';
            CATEGORIES.forEach(cat => {
                let btn = document.createElement('button');
                btn.className = `shop-tab ${game.shopCat === cat ? 'active' : ''}`;
                btn.innerText = cat;
                btn.onclick = () => { game.shopCat = cat; renderShop(); };
                tabs.appendChild(btn);
            });

            // Render Items
            let grid = document.getElementById('shop-content');
            grid.innerHTML = '';
            
            RESEARCH.filter(r => r.cat === game.shopCat).forEach(r => {
                let lvl = game.upgrades[r.id] || 0;
                let cost = Math.floor(r.cost * Math.pow(1.3, lvl)); // Reduced scaling from 1.5 to 1.3
                let pct = (lvl / r.max) * 100;
                
                let item = document.createElement('div');
                item.className = 'shop-item';
                item.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h3>${r.name}</h3>
                        <div class="shop-lvl">Lvl ${lvl}/${r.max}</div>
                    </div>
                    <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
                    <p>${r.desc}</p>
                    <button class="shop-btn" onclick="buyUpgrade('${r.id}')" 
                        ${(lvl >= r.max || game.cash < cost) ? 'disabled' : ''}>
                        ${lvl >= r.max ? 'MAXED' : 'Research ($' + cost + ')'}
                    </button>
                `;
                grid.appendChild(item);
            });
        }

        function buyUpgrade(id) {
            try {
                if(!id) throw new Error("Invalid upgrade ID");
                let r = RESEARCH.find(x => x.id === id);
                if(!r) throw new Error("Upgrade not found: " + id);
                
                let lvl = game.upgrades[id] || 0;
                let cost = Math.floor(r.cost * Math.pow(1.3, lvl)); // Reduced scaling from 1.5 to 1.3
                
                if(lvl < r.max && game.cash >= cost) {
                    game.cash -= cost;
                    game.upgrades[id] = lvl + 1;
                    renderShop();
                    updateUI();
                    saveGame();
                    showToast("Researched: " + r.name);
                    
                    // Visual feedback
                    createParticle(game.core.x*TILE_SIZE, game.core.y*TILE_SIZE, 'text', 'UPGRADE COMPLETE');
                } else {
                    showToast("Cannot afford or Maxed");
                }
            } catch(e) {
                console.error(e);
                showToast("Error: " + e.message);
            }
        }

        function abortGame() {
            if(confirm("Abort Mission? This will trigger a system failure.")) {
                game.hp = 0;
                gameOver();
            }
        }

        function resetGame() {
            if(confirm("Reset Game? All progress will be lost.")) {
                localStorage.removeItem('coreDefenseSave');
                location.reload();
            }
        }

        function sellAllTurrets() {
            if(game.turrets.length === 0) return;
            if(confirm("Sell ALL turrets? This will remove all defenses.")) {
                let refund = 0;
                for(let t of game.turrets) {
                    refund += Math.floor(t.type.cost / 2); // 50% refund
                    setGrid(t.gx, t.gy, 0);
                }
                game.cash += refund;
                game.turrets = [];
                game.focus = null;
                document.getElementById('ctx-menu').style.display = 'none';
                updateFlow();
                updateUI();
                showToast("Sold All (+$" + refund + ")");
            }
        }
        function canBuild(gx, gy) {
            if(gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return false;
            if(getGrid(gx, gy) !== 0) return false;
            if(game.selection === -1) return false;
            let type = TYPES[game.selection];
            
            let cost = type.cost;
            if(game.upgrades.build_cost) cost = Math.floor(cost * (1 - game.upgrades.build_cost * 0.05));

            if(game.cash < cost) return false;
            return true;
        }

        function upgradeTurret() {
            if(!game.focus) return;
            let t = game.focus;
            if(t.type.type === 'wall') {
                showToast("Cannot Upgrade Walls");
                return;
            }
            let cost = Math.floor(t.type.cost * 0.5 * t.level);
            
            if(game.cash >= cost) {
                game.cash -= cost;
                t.level++;
                updateUI();
                closeCtxMenu();
                showToast("Upgraded to Lvl " + t.level);
                saveGame();
            } else {
                showToast("Need $" + cost);
            }
        }

        function sellTurret() {
            if(!game.focus) return;
            let t = game.focus;
            let refundPct = 0.5;
            if(game.upgrades.refund) refundPct += game.upgrades.refund * 0.1;
            
            let refund = Math.floor(t.type.cost * refundPct);
            
            game.cash += refund;
            setGrid(t.gx, t.gy, 0);
            
            let idx = game.turrets.indexOf(t);
            if(idx > -1) game.turrets.splice(idx, 1);
            
            updateFlow();
            updateUI();
            closeCtxMenu();
            showToast("Sold (+$" + refund + ")");
            saveGame();
        }

        function closeCtxMenu() {
            document.getElementById('ctx-menu').style.display = 'none';
            game.focus = null;
        }

        function centerCamera() {
            camera.zoom = 1;
            camera.x = game.core.x * TILE_SIZE + TILE_SIZE/2;
            camera.y = game.core.y * TILE_SIZE + TILE_SIZE/2;
        }

        // --- Save / Load ---
        function saveGame() {
            if(game.over) {
                localStorage.removeItem('coreDefenseSave');
                return;
            }
            
            // Serialize
            let data = {
                hp: game.hp,
                cash: game.cash,
                wave: game.wave,
                grid: Array.from(game.grid),
                turrets: game.turrets.map(t => {
                    let s = {...t}; 
                    s.typeIdx = TYPES.indexOf(t.type); 
                    delete s.type; 
                    return s;
                }),
                camera: camera,
                enemiesToSpawn: game.enemiesToSpawn,
                active: game.active,
                enemies: game.enemies,
                bullets: game.bullets,
                upgrades: game.upgrades,
                shopCat: game.shopCat
            };
            
            try {
                localStorage.setItem('coreDefenseSave', JSON.stringify(data));
            } catch(e) {
                console.error(e);
            }
        }

        function loadGame() {
            let json = localStorage.getItem('coreDefenseSave');
            if(!json) return false;
            
            try {
                let data = JSON.parse(json);
                
                game.hp = data.hp;
                game.cash = data.cash;
                game.wave = data.wave;
                game.active = data.active;
                game.enemiesToSpawn = data.enemiesToSpawn;
                game.upgrades = data.upgrades || {};
                game.shopCat = data.shopCat || 'Weaponry';
                game.grid = new Int8Array(data.grid); 
                
                if(data.camera) camera = data.camera;

                game.turrets = data.turrets.map(t => {
                    t.type = TYPES[t.typeIdx];
                    return t;
                });
                
                game.enemies = data.enemies || [];
                game.bullets = data.bullets || [];

                updateFlow();
                updateUI();
                showToast("Welcome Back");
                
                game.over = false; 
                document.getElementById('game-over').style.display = 'none';
                return true;

            } catch(e) {
                console.error(e);
                return false;
            }
        }
        
        // Auto-save on page exit
        window.addEventListener('beforeunload', () => {
            saveGame();
        });

        // Also auto-save on visibility change (mobile/tab switch)
        document.addEventListener('visibilitychange', () => {
             if (document.visibilityState === 'hidden') {
                 saveGame();
             }
        });

        // --- Rendering ---
        function draw() {
            // Chaos - Screen Shake
            let shakeX = 0, shakeY = 0;
            if(game.upgrades.shake > 0) {
                let mag = game.upgrades.shake * 2;
                shakeX = (Math.random() - 0.5) * mag;
                shakeY = (Math.random() - 0.5) * mag;
            }

            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height); 

            ctx.save();
            
            // Camera Transform
            ctx.translate(canvas.width/2 + shakeX, canvas.height/2 + shakeY);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Chromatic Glitch
            if(game.upgrades.chromatic > 0 && Math.random() < 0.02 * game.upgrades.chromatic) {
                ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},0.1)`;
                ctx.fillRect(camera.x - 1000, camera.y - 1000, 2000, 2000);
            }

            // Draw Grid (Optimization: Only visible)
            let vw = canvas.width / camera.zoom;
            let vh = canvas.height / camera.zoom;
            
            let startCol = Math.max(0, Math.floor((camera.x - vw/2) / TILE_SIZE));
            let endCol = Math.min(GRID_W, Math.ceil((camera.x + vw/2) / TILE_SIZE));
            let startRow = Math.max(0, Math.floor((camera.y - vh/2) / TILE_SIZE));
            let endRow = Math.min(GRID_H, Math.ceil((camera.y + vh/2) / TILE_SIZE));

            ctx.strokeStyle = 'rgba(102, 252, 241, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=startCol; x<=endCol; x++) { ctx.moveTo(x*TILE_SIZE, startRow*TILE_SIZE); ctx.lineTo(x*TILE_SIZE, endRow*TILE_SIZE); }
            for(let y=startRow; y<=endRow; y++) { ctx.moveTo(startCol*TILE_SIZE, y*TILE_SIZE); ctx.lineTo(endCol*TILE_SIZE, y*TILE_SIZE); }
            ctx.stroke();

            // Spawns
            ctx.fillStyle = 'rgba(225, 112, 85, 0.1)';
            for(let s of game.spawns) {
                if(s.x < startCol || s.x > endCol || s.y < startRow || s.y > endRow) continue;
                
                ctx.fillRect(s.x*TILE_SIZE, s.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.save();
                ctx.strokeStyle = '#e17055';
                ctx.beginPath();
                ctx.moveTo(s.x*TILE_SIZE, s.y*TILE_SIZE); ctx.lineTo(s.x*TILE_SIZE+TILE_SIZE, s.y*TILE_SIZE+TILE_SIZE);
                ctx.moveTo(s.x*TILE_SIZE+TILE_SIZE, s.y*TILE_SIZE); ctx.lineTo(s.x*TILE_SIZE, s.y*TILE_SIZE+TILE_SIZE);
                ctx.stroke();
                ctx.restore();
            }
            
            // Turrets & Walls (Draw from grid to handle z-index by row if needed, or just iterate turrets)
            // Iterating turrets is faster if sparse.
            for(let t of game.turrets) {
                if(t.gx < startCol || t.gx > endCol || t.gy < startRow || t.gy > endRow) continue;
                
                let px = t.gx * TILE_SIZE;
                let py = t.gy * TILE_SIZE;

                // Base
                ctx.fillStyle = '#1f2833';
                ctx.fillRect(px+2, py+2, TILE_SIZE-4, TILE_SIZE-4);
                
                // Color
                ctx.fillStyle = t.type.color;
                if(game.upgrades.chromatic && Math.random() < 0.05) ctx.fillStyle = '#fff';

                if(t.type.type === 'wall') {
                    ctx.fillRect(px+4, py+4, TILE_SIZE-8, TILE_SIZE-8);
                } else {
                    // Turret Body
                    ctx.beginPath();
                    ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Turret Head
                    if(t.type.type !== 'aura') {
                        ctx.save();
                        ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2);
                        ctx.rotate(t.angle);
                        ctx.fillRect(0, -3, TILE_SIZE/2, 6);
                        ctx.restore();
                    } else {
                        // Aura
                        ctx.strokeStyle = t.type.color;
                        ctx.beginPath();
                        ctx.arc(px+TILE_SIZE/2, py+TILE_SIZE/2, (game.frame%20) + 10, 0, Math.PI*2);
                        ctx.stroke();
                    }
                }
            }
            
            // Core
            let cx = game.core.x*TILE_SIZE + TILE_SIZE/2;
            let cy = game.core.y*TILE_SIZE + TILE_SIZE/2;
            let r = 15 + Math.sin(game.frame * 0.05) * 2;
            
            // Core Glow
            ctx.fillStyle = 'rgba(225, 112, 85, 0.2)';
            if(game.upgrades.bloom) {
                ctx.shadowBlur = 20 + Math.sin(game.frame*0.1)*10;
                ctx.shadowColor = '#e17055';
            }
            ctx.beginPath(); ctx.arc(cx, cy, r + 10, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            
            // Core Shape
            ctx.fillStyle = '#e17055';
            ctx.beginPath();
            for(let i=0; i<6; i++) {
                let angle = i * Math.PI/3;
                ctx.lineTo(cx + Math.cos(angle)*r, cy + Math.sin(angle)*r);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='bold 10px Rajdhani'; 
            ctx.fillText('CORE', cx, cy);

            // Entities: Enemies
            for(let e of game.enemies) {
                if(e.x < camera.x - vw/2 - 50 || e.x > camera.x + vw/2 + 50 || 
                   e.y < camera.y - vh/2 - 50 || e.y > camera.y + vh/2 + 50) continue;

                ctx.fillStyle = e.slow > 0 ? '#74b9ff' : '#e74c3c';
                if(e.stun > 0) ctx.fillStyle = '#ffeaa7';
                
                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.rotate(game.frame * 0.1);
                
                if(e.type === 'glitch') {
                    if(Math.random() < 0.2) ctx.translate(Math.random()*4-2, Math.random()*4-2); // Glitch shake
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#66fcf1';
                    ctx.shadowBlur = 10;
                }

                ctx.fillRect(-8, -8, 16, 16);
                ctx.restore();
                ctx.shadowBlur = 0;

                // HP Bar
                let hpPct = e.hp / (20 * Math.pow(1.15, game.wave));
                ctx.fillStyle = '#333';
                ctx.fillRect(e.x - 10, e.y - 15, 20, 4);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(e.x - 10, e.y - 15, 20 * Math.min(1, hpPct), 4);
            }

            // Bullets
            for(let b of game.bullets) {
                if(b.type === 'pulse') {
                     ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
                     ctx.strokeStyle = b.color; ctx.lineWidth = 5; ctx.stroke();
                     continue;
                }

                if(b.x < camera.x - vw/2 - 50 || b.x > camera.x + vw/2 + 50 || 
                   b.y < camera.y - vh/2 - 50 || b.y > camera.y + vh/2 + 50) continue;

                ctx.fillStyle = b.color;
                if(game.upgrades.bloom) {
                    ctx.shadowColor = b.color; 
                    ctx.shadowBlur = 5;
                }
                ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Clouds
            for(let c of game.clouds) {
                if(c.x < camera.x - vw/2 - 50 || c.x > camera.x + vw/2 + 50 || 
                   c.y < camera.y - vh/2 - 50 || c.y > camera.y + vh/2 + 50) continue;
                
                ctx.fillStyle = 'rgba(102, 252, 241, 0.2)';
                ctx.beginPath(); ctx.arc(c.x, c.y, 50, 0, Math.PI*2); ctx.fill();
            }

            // Particles
            for(let p of game.particles) {
                if(p.x < camera.x - vw/2 - 50 || p.x > camera.x + vw/2 + 50 || 
                   p.y < camera.y - vh/2 - 50 || p.y > camera.y + vh/2 + 50) continue;

                if(p.type === 'spark' || p.type === 'debris') {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 60;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    ctx.globalAlpha = 1;
                }
                if(p.type === 'shockwave') {
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = p.life / 30;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, (30 - p.life) * 10, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                if(p.type === 'text') {
                    ctx.fillStyle = p.color;
                    ctx.font = 'bold 12px Rajdhani';
                    ctx.globalAlpha = p.life / 40;
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.globalAlpha = 1;
                }
            }

            // Build Ghost
            if(game.selection > -1) {
                let gx = Math.floor((lastMouse.x / camera.zoom + camera.x - canvas.width/2) / TILE_SIZE);
                let gy = Math.floor((lastMouse.y / camera.zoom + camera.y - canvas.height/2) / TILE_SIZE);
                
                // My camera logic above (draw transform) was:
                // translate(W/2, H/2) -> scale -> translate(-camX, -camY)
                // Mouse to World:
                // WorldX = (MouseX - W/2) / scale + camX
                
                gx = Math.floor(((lastMouse.x - canvas.width/2) / camera.zoom + camera.x) / TILE_SIZE);
                gy = Math.floor(((lastMouse.y - canvas.height/2) / camera.zoom + camera.y) / TILE_SIZE);

                if(gx >= 0 && gx < GRID_W && gy >= 0 && gy < GRID_H) {
                    let type = TYPES[game.selection];
                    let px = gx * TILE_SIZE;
                    let py = gy * TILE_SIZE;
                    
                    let valid = canBuild(gx, gy);
                    ctx.strokeStyle = valid ? type.color : '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                    ctx.setLineDash([]);

                    // Range
                    ctx.beginPath();
                    ctx.arc(px+TILE_SIZE/2, py+TILE_SIZE/2, type.range * TILE_SIZE, 0, Math.PI*2);
                    ctx.stroke();
                }
            }
            
            // Focus Range
            if(game.focus) {
                let range = getStat(game.focus, 'range') * TILE_SIZE;
                ctx.strokeStyle = 'rgba(102, 252, 241, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(game.focus.x, game.focus.y, range, 0, Math.PI*2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
            
            if(game.paused) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText("PAUSED", canvas.width/2, canvas.height/2);
            }

            // requestAnimationFrame(draw); // Removed for loop()
        }


        // --- Interaction ---
        function selectBuild(idx) {
            game.selection = idx;
            document.getElementById('ctx-menu').style.display = 'none';
            updateUI();
        }

        function handleClick(e) {
            if(game.over) return;
            // Prevent if panning (distinguish click vs drag)
            if(isPanning) return; 

            // World Coords
            let rect = canvas.getBoundingClientRect();
            let wx = (e.clientX - rect.left - canvas.width/2) / camera.zoom + camera.x;
            let wy = (e.clientY - rect.top - canvas.height/2) / camera.zoom + camera.y;
            let gx = Math.floor(wx / TILE_SIZE);
            let gy = Math.floor(wy / TILE_SIZE);

            // Place Turret
            if(game.selection !== -1) {
                if(getGrid(gx, gy) === 0) {
                    let type = TYPES[game.selection];
                    if(game.cash >= type.cost) {
                        // Test Blocking
                        setGrid(gx, gy, 1);
                        updateFlow();
                        
                        // Check if path exists from all spawns
                        let block = false;
                        for(let s of game.spawns) {
                            if(getFlow(s.x, s.y) === 9999) block = true;
                        }

                        if(!block) {
                            let cost = type.cost;
                            if(game.upgrades.build_cost) cost = Math.floor(cost * (1 - game.upgrades.build_cost * 0.05));

                            game.cash -= cost;
                            game.turrets.push({
                                x: gx*TILE_SIZE + TILE_SIZE/2,
                                y: gy*TILE_SIZE + TILE_SIZE/2,
                                gx: gx, gy: gy,
                                type: type,
                                cooldown: 0,
                                rangePx: type.range * TILE_SIZE,
                                dmg: type.dmg,
                                rate: type.rate,
                                level: 1
                            });
                            updateUI();
                        } else {
                            // Revert
                            setGrid(gx, gy, 0);
                            updateFlow();
                            showToast("Path Blocked");
                        }
                    } else {
                        showToast("No Cash");
                    }
                } else {
                    // Clicking on existing while building? Maybe nothing.
                }
            } 
            // Select Turret
            else {
                let clicked = game.turrets.find(t => t.gx === gx && t.gy === gy);
                if(clicked) {
                    game.focus = clicked;
                    let menu = document.getElementById('ctx-menu');
                    menu.style.display = 'block';
                    menu.style.left = (e.clientX) + 'px';
                    menu.style.top = (e.clientY) + 'px';
                    
                    let cost = Math.floor(clicked.type.cost * 0.5 * clicked.level);
                    document.getElementById('ctx-up-cost').innerText = `($${cost})`;
                    document.getElementById('ctx-sell-val').innerText = `($${Math.floor(clicked.type.cost/2)})`;
                } else {
                    document.getElementById('ctx-menu').style.display = 'none';
                    game.focus = null;
                }
            }
        }

        canvas.addEventListener('mousemove', e => {
            let rect = canvas.getBoundingClientRect();
            
            if (isPanning) {
                camera.x -= (e.clientX - lastMouse.x) / camera.zoom;
                camera.y -= (e.clientY - lastMouse.y) / camera.zoom;
                lastMouse = { x: e.clientX, y: e.clientY };
                
                // Clamp Camera
                let vw = canvas.width / camera.zoom;
                let vh = canvas.height / camera.zoom;
                camera.x = Math.max(-vw/2, Math.min(camera.x, GRID_W*TILE_SIZE - vw/2));
                camera.y = Math.max(-vh/2, Math.min(camera.y, GRID_H*TILE_SIZE - vh/2));
                return;
            }

            let wx = (e.clientX - rect.left - canvas.width/2) / camera.zoom + camera.x;
            let wy = (e.clientY - rect.top - canvas.height/2) / camera.zoom + camera.y;
            game.hover.x = Math.floor(wx / TILE_SIZE);
            game.hover.y = Math.floor(wy / TILE_SIZE);
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousedown', e => {
            if(game.over) return;
            
            // Right Click or Middle Click -> Pan
            // Or Left Click if no tool selected (and not on turret?) - Simplified: Left=Interact, Right=Pan
            if (e.button === 2 || (e.button === 0 && game.selection === -1 && !game.focus)) {
                // Check if we clicked a turret, if so select it instead of pan
                let rect = canvas.getBoundingClientRect();
                let wx = (e.clientX - rect.left - canvas.width/2) / camera.zoom + camera.x;
                let wy = (e.clientY - rect.top - canvas.height/2) / camera.zoom + camera.y;
                let gx = Math.floor(wx / TILE_SIZE);
                let gy = Math.floor(wy / TILE_SIZE);
                
                if (game.turrets.find(t => t.gx === gx && t.gy === gy)) {
                     handleClick(e); // Pass through to logic
                     return;
                }
                
                isPanning = true;
                lastMouse = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            } else {
                handleClick(e);
            }
        });
        
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            let rect = canvas.getBoundingClientRect();
            let mx = e.clientX - rect.left - canvas.width/2;
            let my = e.clientY - rect.top - canvas.height/2;
            
            // World point under mouse before zoom
            let wx = mx / camera.zoom + camera.x;
            let wy = my / camera.zoom + camera.y;

            if (e.deltaY < 0) camera.zoom = Math.min(camera.zoom * 1.02, 5);
            else camera.zoom = Math.max(camera.zoom / 1.02, 0.2);
            
            // Adjust camera so wx is still under mx
            // mx / new_zoom + new_camera_x = wx
            camera.x = wx - mx / camera.zoom;
            camera.y = wy - my / camera.zoom;
        }, { passive: false });
        
        canvas.addEventListener('mouseup', () => {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        });
        
        window.addEventListener('resize', resize);

        // --- UI Utils ---
        function updateUI() {
            document.getElementById('ui-hp').innerText = Math.ceil(game.hp);
            document.getElementById('ui-cash').innerText = game.cash;
            document.getElementById('ui-wave').innerText = game.wave;
            
            // Highlight selection
            for(let i=0; i<5; i++) {
                let btn = document.getElementById('btn-'+i);
                if(i === game.selection) btn.classList.add('selected');
                else btn.classList.remove('selected');
                
                let cost = TYPES[i].cost;
                if(game.upgrades.build_cost) cost = Math.floor(cost * (1 - game.upgrades.build_cost * 0.05));

                if(game.cash < cost) btn.classList.add('disabled');
                else btn.classList.remove('disabled');
            }
            
            // Update Cancel Button
            let cancelBtn = document.getElementById('btn-cancel');
            if (game.selection !== -1) {
                cancelBtn.style.display = 'flex';
                cancelBtn.style.borderColor = '#ff4757';
                cancelBtn.style.boxShadow = '0 0 10px #ff4757';
            } else {
                cancelBtn.style.display = 'none';
            }
        }

        function showToast(txt) {
            let t = document.getElementById('toast');
            t.innerText = txt;
            t.style.opacity = 1; t.style.top = '120px';
            setTimeout(() => { t.style.opacity = 0; t.style.top = '100px'; }, 1000);
        }

        window.addEventListener('keydown', e => {
            if (e.key >= '1' && e.key <= '5') selectBuild(parseInt(e.key)-1);
            if (e.key === 'Escape') selectBuild(-1);
        });

        // Start
        resetGrid();
        if(!loadGame()) {
            // New game defaults
            game.cash = 150;
            if(game.upgrades && game.upgrades.start_cash) game.cash += game.upgrades.start_cash * 50;
        }
        resize();
        updateUI();
        setInterval(update, 1000/60); // Fixed time step for logic
        draw();

    </script>
</body>
</html>